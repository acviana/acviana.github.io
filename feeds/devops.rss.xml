<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>The Other Side of the Screen</title><link>http://acviana.github.io/</link><description>"On the other side of the screen it all seems so easy." - Tron (1982)</description><atom:link href="http://acviana.github.io/feeds/devops.rss.xml" rel="self"></atom:link><lastBuildDate>Sun, 24 Nov 2013 00:00:00 -0500</lastBuildDate><item><title>The Joy of "Screen"</title><link>http://acviana.github.io/posts/2013/the-joy-of-screen/</link><description>&lt;p&gt;Because I frequently work remotely as well as run long processes I recently gave up my desktop system at work in exchange for a laptop and a couple of virtual machines. I use the laptop for day-to-day work but offload longer computations or automated processes to my VMs. But before I could fully take advantage of this setup  I had to solve a new problem I didn't have to worry about with my desktop, how do I run a process remotely without maintaining an open SSH connection? &lt;/p&gt;
&lt;p&gt;I went to our IT department with this question and my favorite sys admin&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt; turned me onto the joy of &lt;a href="http://en.wikipedia.org/wiki/GNU_Screen"&gt;Screen&lt;/a&gt;. Since then I've been spreading the word around my branch about this awesome little tool. Screen is a robust little piece of software that allows you to manage your shell session in a variety of ways. Screen can do a lot and it's worth taking the time to read through some tutorials but I'll explain my basic workflow in this post to start a process on a remote host and leave it running after closing the SSH connection. &lt;/p&gt;
&lt;p&gt;First you SSH into you remote machine as normal and then type&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;screen&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;ls&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This is going to return a list of all the Screen&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt; sessions you have active on your machine. If this is your first time using screen you should see something like &lt;code&gt;No Sockets found in ...&lt;/code&gt;. Great, now we're going to start up our first Screen session, I'm going to call this one &lt;code&gt;making_science&lt;/code&gt;, so then I type:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;screen&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt; &lt;span class="n"&gt;making_science&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;And then you'll get a new command line prompt, you are now "in" your Screen session, or as Screen calls it "attached". If you run &lt;code&gt;screen -ls&lt;/code&gt; again you'll now get something like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;there&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;screen&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="mf"&gt;48625.&lt;/span&gt;&lt;span class="n"&gt;making_science&lt;/span&gt;    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Attached&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;Socket&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;blah&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;blah&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now go ahead and launch your long script, I usually run it in the background by appending script with an ampersand (&lt;code&gt;&amp;amp;&lt;/code&gt;) like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;make_some_science&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;And now we finally get to the good part, we're going to detach the session without killing the process, even if you close the SSH connection. You can do this either by typing &lt;code&gt;ctrl + a&lt;/code&gt; then &lt;code&gt;:detach&lt;/code&gt;,  or if you don't have those key bindings, &lt;code&gt;screen -D&lt;/code&gt;. Anytime you want to check back in one it just reattach your screen session on the same host with &lt;code&gt;screen -r&lt;/code&gt; and everything will be just as you left it, even your command history. When you're finally done with your session you can just kill it with &lt;code&gt;exit&lt;/code&gt; and it'll be removed from your list of screens.&lt;/p&gt;
&lt;p&gt;Lastly, if like me you're suspicious by nature, you're going to want to check to make sure your process is &lt;em&gt;actualy&lt;/em&gt; still running so you don't die a little inside when you come back to work the next morning expecting a pile of fresh data and instead get a stack trace. There are a variety of tools that allow you to do this, the two command line solutions I use are &lt;code&gt;top&lt;/code&gt; &lt;sup id="fnref:3"&gt;&lt;a class="footnote-ref" href="#fn:3" rel="footnote"&gt;3&lt;/a&gt;&lt;/sup&gt; and &lt;code&gt;ps&lt;/code&gt;. Either one will list the processed currently running on your machine. I usually start up a process with screen, detach the session, confirm that the process is still running with &lt;code&gt;top&lt;/code&gt; or &lt;code&gt;ps&lt;/code&gt; and &lt;em&gt;then&lt;/em&gt; close the SSH connection. If I'm feeling extra careful I'll check the log files from another host after closing th SSH to make sure things are still humming along. &lt;/p&gt;
&lt;p&gt;And that's it. Go ask your IT department very nicely if they can build you a VM and then unleash your codebase while you go about your life. Horray! &lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;If you're going to do any serious DevOps work make friends with you IT staff. Ask them for help nicely and thank them profusely. Buy them beers. A good relationship with your sys admins in invaluable to getting sh*t done. This really shouldn't even be a footnote.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;Screen is inconsistently capitalized in the websites and blogs I saw. I decided to follow the convention in the GNU &lt;a href="https://www.gnu.org/software/screen/"&gt;docs&lt;/a&gt; and treat it as a proper noun. I bring this up here because this is the first place in this post where Screen isn't capitalized because it starts a sentence. I also bring it up because I'm a nerd.&amp;#160;&lt;a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:3"&gt;
&lt;p&gt;Depending on your version of &lt;code&gt;top&lt;/code&gt; you can type &lt;code&gt;u&lt;/code&gt; on the main screen and then your username to view all the processes being run by your user name. Given that &lt;code&gt;top&lt;/code&gt; shows all the system processes this helps remove all the ones you don't care about.&amp;#160;&lt;a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alex C. Viana</dc:creator><pubDate>Sun, 24 Nov 2013 00:00:00 -0500</pubDate><guid>tag:acviana.github.io,2013-11-24:posts/2013/the-joy-of-screen/</guid><category>devops</category></item><item><title>A Basic Automation Setup for Astronomy: Part 1</title><link>http://acviana.github.io/posts/2013/a-basic-automation-setup/</link><description>&lt;p&gt;For one of my projects at work I engineered an automation platform for one of our instrument teams. This platform allows us to automatically execute 20+ daily scripts, written in a variety of programming languages, as data is coming down from the telescope. All the scripts for our team, from the downloading the data, copying and indexing the data in an SQL database, running in-house scripts, and system self-diagnostics run on the same automation platform. Adding a script to this platform requires as little as 4 lines of code. Our codebase is updated with hourly builds from our team of 6 developers and all execution and maintenance is performed via a service account on a Linux Red Hat virtual machine.&lt;/p&gt;
&lt;p&gt;This is going to be a series of posts where I'm going to cover all the odds and ends I had to stick together to build this system. This is far from a generalized solution but hopefully you can learn from my mistakes and build something to suit your own needs faster and better than I did.&lt;/p&gt;
&lt;p&gt;As an aside, this is what I consider to be the DevOps side of my job. It's only in the last year that this has become part of my work and it's only now that I'm starting to identify this as a valuable skill in response to a hard problem. Previously, I was just embarrassed I kept breaking things. But looking back on it, automating this system in this way is one of the hardest things I've done in my job. I'm fortunate I have a team that didn't tell me to stop wasting my time and do it the old way by running everything by hand. And now that it's up and running I haven't had to fix it in weeks.&lt;/p&gt;
&lt;p&gt;In this first post we'll just cover combining the automated execution solution (cron) with the environment configuration solution (Ureka).&lt;/p&gt;
&lt;h3&gt;Cron: Running Your Code&lt;/h3&gt;
&lt;p&gt;At the heart of our system, like many automation solutions, is the Unix job scheduler &lt;a href="http://en.wikipedia.org/wiki/Cron"&gt;cron&lt;/a&gt;. There are other applications our team considered using to fill this role such as &lt;a href="http://research.cs.wisc.edu/htcondor/"&gt;Condor&lt;/a&gt; a distributed computing platform, &lt;a href="http://jenkins-ci.org/"&gt;Jenkins CI&lt;/a&gt; a java-based web frontend for continuous integration, &lt;a href="http://en.wikipedia.org/wiki/Launchd"&gt;launchd&lt;/a&gt; an OSX job scheduler, and even &lt;a href="http://www.celeryproject.org/"&gt;Celery&lt;/a&gt; a distributed job queue. In the end we chose cron because, once we got it working, it was the most direct and simple solution for our architecture. However, as you'll see later, that simplicity made it incredibly difficult to use with IRAF/PyRAF. But first let's start with some cron basics.&lt;/p&gt;
&lt;p&gt;If you look at some cron tutorials you'll see that cron jobs are scheduled with a syntax like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="mo"&gt;00&lt;/span&gt; &lt;span class="mi"&gt;11&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;my_script&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This will execute &lt;code&gt;my_script.py&lt;/code&gt; every day at 11 am. This is nothing you can't find in any cron tutorial but here are some tricks I found useful that I had to dig around for a little bit. You can also run multiple scripts sequentially on one line by separating them with a semicolon (&lt;code&gt;;&lt;/code&gt;) like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="mo"&gt;00&lt;/span&gt; &lt;span class="mi"&gt;11&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;my_first_script&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;my_second_script&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Each script will run once after the preceding script finishes regardless of the preceding script's exit status. Alternatively, you can make the execution of the second script dependent on the successful completion of the first script with a double ampersand (&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;) like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="mo"&gt;00&lt;/span&gt; &lt;span class="mi"&gt;11&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;my_first_script&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;my_second_script&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now cron is likely going to try to be helpful by emailing you any outputs from your code. The recipient of this email can be defined by setting the &lt;code&gt;MAILTO&lt;/code&gt; variable before the job definitions like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;MAILTO&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;my_team_list&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;my_institution&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;edu&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="mo"&gt;00&lt;/span&gt; &lt;span class="mi"&gt;11&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;my_first_script&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;my_second_script&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You can also define any other variables or alias you want in this same manner. But let's say that you only want to hear from cron when something breaks. You can do this by redirecting &lt;code&gt;STDOUT&lt;/code&gt; just as you would from the command line:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;MAILTO&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;my_team_list&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;my_institution&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;edu&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="mo"&gt;00&lt;/span&gt; &lt;span class="mi"&gt;11&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;my_first_script&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;my_second_script&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;dev&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;null&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now you will only get an email when something gets passed to &lt;code&gt;STDERR&lt;/code&gt;. For our setup, this is all the cron syntax we needed to understand. Now onto setting up you environment.&lt;/p&gt;
&lt;h3&gt;Ureka: Setting Up Your Environment&lt;/h3&gt;
&lt;p&gt;Right now you might be thinking, &lt;em&gt;"My environment is already set up! Right?"&lt;/em&gt;. This is when using cron starts to become a little non-trivial; cron does not know about your &lt;a href="http://stackoverflow.com/questions/2229825/where-can-i-set-environment-variables-that-crontab-will-use"&gt;enviorment variables&lt;/a&gt;, like &lt;em&gt;any&lt;/em&gt; of them. In a lot of applications this is not a big deal, you can just define some environment variables just like I defined &lt;code&gt;MAILTO&lt;/code&gt; above, and you're set. &lt;/p&gt;
&lt;p&gt;But, if you're in astronomy one of your default software tools is likely IRAF/PyRAF. This takes installing software and declaring environment variables to an entirely new level of difficulty. I spent &lt;em&gt;weeks&lt;/em&gt; working on the problem of getting cron to run in an IRAF/PyRAF compatible environment without any success. I tried half a dozen different approaches and talked to several people, all of who confessed to giving up due to the same complication. In the end, I partnered with one of our best IT people and we came up with a solution. The first step of that solution is to use Ureka. &lt;/p&gt;
&lt;p&gt;&lt;a href="http://ssb.stsci.edu/ureka/"&gt;Ureka&lt;/a&gt; is a software package developed by STScI and Gemini. From the website:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Ureka is a collection of useful astronomy software that is generally centered around Python and IRAF. The software provides everything you need to run the data reduction packages provided by STScI and Gemini.  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Ureka is great, it builds a completely isolated IRAF and Python environment in minutes and loads or unloads the environment with a single command. You can run ds9, IRAF, PyRAF, and Python. Plus Python comes loaded with IPython, the IPython notebook, matplotlib, numpy, scipy, and pandas. If you need more than that you can immediately run &lt;code&gt;pip install&lt;/code&gt; because your paths have already been set up for you. You're on your own for IDL though.&lt;/p&gt;
&lt;p&gt;Whether you're like me and work on an institute machine with pre-built libraries or if you're running everything on your own machine and have root, Ureka is worth looking into because it &lt;em&gt;just works&lt;/em&gt;. I spent a lot of time learning to use package managers, building from source into different prefixes, virtualenv, and the ins and outs of pip, but when I got a new virtual machine last month I used Ureka and literally set up everything I needed in 3 commands. I was sold.&lt;/p&gt;
&lt;p&gt;So now we have our automation tool, cron, and our environment setup with Ureka. Now it's time to combine them.&lt;/p&gt;
&lt;h3&gt;Cron + Ureka: Automatic Environment Setup&lt;/h3&gt;
&lt;p&gt;Like we just saw, you can run more than one script on a single line in cron. You can start the Ureka environment with the command &lt;code&gt;ur_setup&lt;/code&gt; and exit with &lt;code&gt;ur_forget&lt;/code&gt;. So I &lt;em&gt;thought&lt;/em&gt; the following command would have been enough to run our scripts:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="mo"&gt;00&lt;/span&gt; &lt;span class="mi"&gt;11&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;ur_setup&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;my_second_script&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;dev&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;null&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;But it doesn't work. Somehow this does not run &lt;code&gt;my_second_script.py&lt;/code&gt; using the environment set up by &lt;code&gt;ur_setup&lt;/code&gt;, my guess is that each script is launched in an independent shell that doesn't propagate variables back to the parent cron environment. This independence is generally a desirable feature so that makes sense, though it makes life hard in our case. This is where everyone I talked to crashed and burned when trying to use cron to automate astronomy software, whether they were using Ureka or not. But eventually one of our IT specialists worked out a wrapper script:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#!/bin/tcsh&lt;/span&gt;
ur_setup
&lt;span class="s2"&gt;&amp;quot;$*&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;It's non-intuitive at first but what it does it runs &lt;code&gt;ur_setup&lt;/code&gt; and then takes a script name as a command line argument and runs that script. Because this is all done in the same shell session the script is launched in the Ureka environment - &lt;em&gt;finally&lt;/em&gt;. I can't tell you how happy I was to finally get this to work. The execution looks like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="mo"&gt;00&lt;/span&gt; &lt;span class="mi"&gt;11&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;cron_setup&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sh&lt;/span&gt; &lt;span class="n"&gt;my_second_script&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;dev&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;null&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Done, Right?&lt;/h3&gt;
&lt;p&gt;That was a bit of a long post, and you might be tempted to call it quits and just run with this setup, but I would encourage you not to. We still have to talk about a deployment solution for your code using your version control system (because your code is version controlled right?), using Python to wrap code written in other languages, using the Python logging module to generate logs. Doesn't that sound nice? I'll put the link to all that right [here] once it's ready.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alex C. Viana</dc:creator><pubDate>Sat, 23 Nov 2013 00:00:00 -0500</pubDate><guid>tag:acviana.github.io,2013-11-23:posts/2013/a-basic-automation-setup/</guid><category>code</category><category>devops</category></item></channel></rss>